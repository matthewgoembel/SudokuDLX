<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Sudoku Solver Comparison</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
  <style>
    /* === Tech Theme and Animated Grid Background === */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    body {
      font-family: 'Orbitron', sans-serif;
      background: radial-gradient(circle at center, #1f1c2c, #000);
      color: #eee;
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    body::before {
      content: "";
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background:
        linear-gradient(transparent 50%, rgba(255,255,255,0.02) 50%) 0 0,
        linear-gradient(to right, transparent 50%, rgba(255,255,255,0.02) 50%) 0 0;
      background-size: 40px 40px;
      animation: moveGrid 15s linear infinite;
      pointer-events: none;
      z-index: -1;
    }
    @keyframes moveGrid {
      from { background-position: 0 0; }
      to   { background-position: 40px 40px; }
    }
    h1 {
      margin: 20px 0;
      font-size: 2.5em;
      text-align: center;
      text-shadow: 0 0 10px #8acdea, 0 0 20px #8acdea;
    }
    .controls {
      margin-bottom: 20px;
    }
    select, button {
      font-family: 'Orbitron', sans-serif;
      background: #2e2a44;
      border: 1px solid #8acdea;
      color: #8acdea;
      padding: 8px 16px;
      margin: 0 8px;
      border-radius: 4px;
      box-shadow: 0 0 5px rgba(138,205,234,0.7);
      cursor: pointer;
      transition: all 0.3s ease;
    }
    select:hover, button:hover {
      background: #8acdea;
      color: #2a1a3d;
      box-shadow: 0 0 15px #8acdea;
    }
    .container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 40px;
      width: 100%;
      flex-grow: 1;
      overflow-y: auto;
      padding-bottom: 20px;
    }
    .panel {
      backdrop-filter: blur(10px);
      background: rgba(30,30,60,0.6);
      border: 1px solid #4e4e5e;
      box-shadow: 0 0 20px rgba(78,78,94,0.7), inset 0 0 10px rgba(255,255,255,0.1);
      border-radius: 8px;
      padding: 15px;
      min-width: 280px;
    }
    .panel h2 {
      margin-top: 0;
      font-size: 1.2em;
      color: #8acdea;
    }
    table {
      border-collapse: collapse;
      background: transparent;
      margin: 0 auto;
    }
    td {
      width: 30px;
      height: 30px;
      text-align: center;
      background: rgba(20,20,40,0.8);
      border: 1px solid rgba(255,255,255,0.2);
      transition: background 0.3s;
    }
    td:hover {
      background: rgba(78,78,94,0.8);
    }
    .thick-border-top   { border-top:    3px solid #8acdea; }
    .thick-border-left  { border-left:   3px solid #8acdea; }
    .thick-border-right { border-right:  3px solid #8acdea; }
    .thick-border-bot   { border-bottom: 3px solid #8acdea; }
    .info {
      margin-top: 8px;
      font-weight: bold;
      color: #ffffff;
    }
    footer {
      text-align: center;
      padding: 10px;
      font-size: 0.9em;
      color: #aaa;
    }
  </style>
</head>
<body>

  <h1>Sudoku Solver: Backtracking vs. Dancing Links</h1>
  <div class="controls">
    <label for="puzzleSelect">Choose a puzzle:</label>
    <select id="puzzleSelect"></select>
    <button id="loadPuzzleBtn">Load Puzzle</button>
    <button id="solveBtn">Solve Both</button>
  </div>

  <div class="container">
    <div class="panel">
      <h2>Input Puzzle</h2>
      <table id="inputGrid"></table>
    </div>
    <div class="panel">
      <h2>Backtracking</h2>
      <table id="btGrid"></table>
      <div id="btInfo" class="info"></div>
    </div>
    <div class="panel">
      <h2>Dancing Links</h2>
      <table id="dlxGrid"></table>
      <div id="dlxInfo" class="info"></div>
    </div>
  </div>

  <footer>Powered by Backtracking &amp; DLX | Tech Theme by ChatGPT</footer>

<script>
// === Three Hard-coded Puzzles ===
const puzzles = [
  { name: "Easy",
    str: "530070000600195000098000060800060003400803001700020006060000280000419005000080079" },
  { name: "Medium",
    str: "000260701680070090190004500820100040004602900050003028009300074040050036703018000" },
  { name: "Hard",
    str: "000000907000420180000705026100904000050000040000507009920108000034059000507000000" }
];

// === Utility Functions ===
function parsePuzzle(str) {
  const grid = [];
  for (let r = 0; r < 9; r++) {
    grid[r] = [];
    for (let c = 0; c < 9; c++) {
      const ch = str[r*9 + c];
      grid[r][c] = (ch === '0' || ch === '.') ? 0 : +ch;
    }
  }
  return grid;
}

function renderGrid(grid, tableId) {
  const table = document.getElementById(tableId);
  table.innerHTML = "";
  for (let r = 0; r < 9; r++) {
    const row = table.insertRow();
    for (let c = 0; c < 9; c++) {
      const cell = row.insertCell();
      cell.textContent = grid[r][c] || "";
      if (r % 3 === 0) cell.classList.add("thick-border-top");
      if (c % 3 === 0) cell.classList.add("thick-border-left");
      if (c === 8)      cell.classList.add("thick-border-right");
      if (r === 8)      cell.classList.add("thick-border-bot");
    }
  }
}

// --- Recursive Backtracking Solver ---
let btCalls = 0;
function validBT(g, r, c, v) {
  for (let i = 0; i < 9; i++) {
    if (g[r][i] === v || g[i][c] === v) return false;
  }
  const br = Math.floor(r/3)*3, bc = Math.floor(c/3)*3;
  for (let i = 0; i < 3; i++) for (let j = 0; j < 3; j++) {
    if (g[br+i][bc+j] === v) return false;
  }
  return true;
}

function findEmpty(g) {
  for (let r = 0; r < 9; r++) {
    for (let c = 0; c < 9; c++) {
      if (g[r][c] === 0) return { r, c };
    }
  }
  return null;
}

function solveBT(g) {
  btCalls++;
  const e = findEmpty(g);
  if (!e) return true;
  const { r, c } = e;
  for (let n = 1; n <= 9; n++) {
    if (validBT(g, r, c, n)) {
      g[r][c] = n;
      if (solveBT(g)) return true;
      g[r][c] = 0;
    }
  }
  return false;
}

function backtrackingSolve(orig) {
  const grid = orig.map(r => r.slice());
  btCalls = 0;
  const t0 = performance.now();
  solveBT(grid);
  const t1 = performance.now();
  return { grid, time: (t1 - t0).toFixed(2), calls: btCalls };
}

// --- Dancing Links Solver ---
class DLXNode { constructor() {
  this.L = this; this.R = this; this.U = this; this.D = this; this.C = null;
}}
class ColumnNode extends DLXNode {
  constructor(name) { super(); this.name = name; this.size = 0; }
}

function buildDLX(orig) {
  const header = new ColumnNode("h");
  header.L = header; header.R = header;
  const cols = [];
  for (let i = 0; i < 324; i++) {
    const c = new ColumnNode(i);
    cols.push(c);
    c.R = header; c.L = header.L; header.L.R = c; header.L = c;
    c.U = c; c.D = c;
  }
  function addRow(r, c, n, indices) {
    let first = null;
    indices.forEach(ci => {
      const col = cols[ci];
      const node = new DLXNode();
      node.C = col; node.row = r; node.col = c; node.num = n;
      // vertical
      node.D = col; node.U = col.U; col.U.D = node; col.U = node; col.size++;
      // horizontal
      if (!first) {
        first = node; first.L = first; first.R = first;
      } else {
        node.R = first; node.L = first.L; first.L.R = node; first.L = node;
      }
    });
  }
  for (let r = 0; r < 9; r++) {
    for (let c = 0; c < 9; c++) {
      const v = orig[r][c];
      for (let n = 1; n <= 9; n++) {
        if (v !== 0 && n !== v) continue;
        const b = Math.floor(r/3)*3 + Math.floor(c/3);
        addRow(r, c, n, [
          r*9 + c,
          81  + r*9 + (n-1),
          162 + c*9 + (n-1),
          243 + b*9 + (n-1),
        ]);
      }
    }
  }
  return { header };
}

function cover(c) {
  c.R.L = c.L; c.L.R = c.R;
  for (let i = c.D; i !== c; i = i.D) {
    for (let j = i.R; j !== i; j = j.R) {
      j.D.U = j.U; j.U.D = j.D; j.C.size--;
    }
  }
}

function uncover(c) {
  for (let i = c.U; i !== c; i = i.U) {
    for (let j = i.L; j !== i; j = j.L) {
      j.C.size++; j.D.U = j; j.U.D = j;
    }
  }
  c.R.L = c; c.L.R = c;
}

let dlxSol = null;
function searchDLX(h, k, sol) {
  if (h.R === h) { dlxSol = [...sol]; return true; }
  let c = h.R, min = c.size;
  for (let j = c.R; j !== h; j = j.R) {
    if (j.size < min) { c = j; min = j.size; }
  }
  cover(c);
  for (let r = c.D; r !== c; r = r.D) {
    sol.push(r);
    for (let j = r.R; j !== r; j = j.R) cover(j.C);
    if (searchDLX(h, k+1, sol)) return true;
    sol.pop();
    for (let j = r.L; j !== r; j = j.L) uncover(j.C);
  }
  uncover(c);
  return false;
}

function dlxSolve(orig) {
  const grid = orig.map(r => r.slice());
  const { header } = buildDLX(grid);
  dlxSol = null;
  const t0 = performance.now();
  searchDLX(header, 0, []);
  const t1 = performance.now();
  const res = Array.from({ length: 9 }, () => Array(9).fill(0));
  if (dlxSol) {
    dlxSol.forEach(node => {
      res[node.row][node.col] = node.num;
    });
  }
  return { grid: res, time: (t1 - t0).toFixed(2), ops: dlxSol ? dlxSol.length : 0 };
}

// === UI wiring ===
const puzzleSelect = document.getElementById("puzzleSelect");
const loadBtn      = document.getElementById("loadPuzzleBtn");
const solveBtn     = document.getElementById("solveBtn");

// Populate dropdown
puzzles.forEach((p, i) => {
  const opt = document.createElement("option");
  opt.value = i; opt.textContent = p.name;
  puzzleSelect.appendChild(opt);
});

let current = null;
loadBtn.onclick = () => {
  current = parsePuzzle(puzzles[puzzleSelect.value].str);
  renderGrid(current, "inputGrid");
  document.getElementById("btGrid").innerHTML  = "";
  document.getElementById("dlxGrid").innerHTML = "";
  document.getElementById("btInfo").textContent  = "";
  document.getElementById("dlxInfo").textContent = "";
};
solveBtn.onclick = () => {
  if (!current) return alert("Load a puzzle first!");
  const bt = backtrackingSolve(current);
  renderGrid(bt.grid, "btGrid");
  document.getElementById("btInfo").textContent = `Time: ${bt.time} ms | Calls: ${bt.calls}`;
  const dx = dlxSolve(current);
  renderGrid(dx.grid, "dlxGrid");
  document.getElementById("dlxInfo").textContent = `Time: ${dx.time} ms | Ops: ${dx.ops}`;
};

// auto-load first
loadBtn.click();
</script>

</body>
</html>
