<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Sudoku Solver Comparison</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
  <style>
    /* === Tech Theme and Animated Grid Background === */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    body {
      font-family: 'Orbitron', sans-serif;
      background: radial-gradient(circle at center, #1f1c2c, #000);
      color: #eee;
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    body::before {
      content: "";
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background:
        linear-gradient(transparent 50%, rgba(255,255,255,0.02) 50%) 0 0,
        linear-gradient(to right, transparent 50%, rgba(255,255,255,0.02) 50%) 0 0;
      background-size: 40px 40px;
      animation: moveGrid 15s linear infinite;
      pointer-events: none;
      z-index: -1;
    }
    @keyframes moveGrid {
      from { background-position: 0 0; }
      to   { background-position: 40px 40px; }
    }
    h1 {
      margin: 20px 0;
      font-size: 2.5em;
      text-shadow: 0 0 10px #8acdea, 0 0 20px #8acdea;
    }
    .controls {
      margin-bottom: 20px;
    }
    select, button {
      font-family: 'Orbitron', sans-serif;
      background: #2e2a44;
      border: 1px solid #8acdea;
      color: #8acdea;
      padding: 8px 16px;
      margin: 0 8px;
      border-radius: 4px;
      box-shadow: 0 0 5px rgba(138,205,234,0.7);
      cursor: pointer;
      transition: all 0.3s ease;
    }
    select:hover, button:hover {
      background: #8acdea;
      color: #2a1a3d;
      box-shadow: 0 0 15px #8acdea;
    }
    .container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 40px;
      width: 100%;
      flex-grow: 1;
      overflow-y: auto;
      padding-bottom: 20px;
    }
    .panel {
      backdrop-filter: blur(10px);
      background: rgba(30,30,60,0.6);
      border: 1px solid #4e4e5e;
      box-shadow: 0 0 20px rgba(78,78,94,0.7), inset 0 0 10px rgba(255,255,255,0.1);
      border-radius: 8px;
      padding: 15px;
      min-width: 280px;
    }
    .panel h2 {
      margin-top: 0;
      font-size: 1.2em;
      color: #8acdea;
    }
    table {
      border-collapse: collapse;
      background: transparent;
      margin: 0 auto;
    }
    td {
      width: 30px;
      height: 30px;
      text-align: center;
      background: rgba(20,20,40,0.8);
      border: 1px solid rgba(255,255,255,0.2);
      transition: background 0.3s;
    }
    td:hover {
      background: rgba(78,78,94,0.8);
    }
    .thick-border-top   { border-top:    3px solid #8acdea; }
    .thick-border-left  { border-left:   3px solid #8acdea; }
    .thick-border-right { border-right:  3px solid #8acdea; }
    .thick-border-bot   { border-bottom: 3px solid #8acdea; }
    .info {
      margin-top: 8px;
      font-weight: bold;
      color: #ffffff;
    }
    footer {
      text-align: center;
      padding: 10px;
      font-size: 0.9em;
      color: #aaa;
    }
  </style>
</head>
<body>

  <h1>Sudoku Solver: Backtracking vs. Dancing Links</h1>
  <div class="controls">
    <label for="puzzleSelect">Choose a puzzle:</label>
    <select id="puzzleSelect"></select>
    <button id="loadPuzzleBtn">Load Puzzle</button>
    <button id="solveBtn">Solve Both</button>
  </div>

  <div class="container">
    <div class="panel">
      <h2>Input Puzzle</h2>
      <table id="inputGrid"></table>
    </div>
    <div class="panel">
      <h2>Backtracking</h2>
      <table id="btGrid"></table>
      <div id="btInfo" class="info"></div>
    </div>
    <div class="panel">
      <h2>Dancing Links</h2>
      <table id="dlxGrid"></table>
      <div id="dlxInfo" class="info"></div>
    </div>
  </div>

  <footer></footer>

<script>
// === Hard-coded Puzzles ===
const puzzles = [
  { name: "Easy",
    str: "530070000600195000098342560800060003400803001700020046061530280000419005090080079" },
  { name: "Medium",
    str: "003020600900305001001806400008102900700000008006708200002609500800203009005010300" },
  { name: "Hard",
    str: "000000002000006000001000090000100000000800000000030000040000700000200000300000000" }
];

// === Utilities ===
function parsePuzzle(s) {
  const g=[]; for(let r=0;r<9;r++){g[r]=[];for(let c=0;c<9;c++){const ch=s[r*9+c];g[r][c]=ch==='0'?0:+ch;}}
  return g;
}
function renderGrid(g,id){
  const tbl=document.getElementById(id); tbl.innerHTML="";
  for(let r=0;r<9;r++){
    const row=tbl.insertRow();
    for(let c=0;c<9;c++){
      const cell=row.insertCell(); cell.textContent=g[r][c]||"";
      if(r%3===0) cell.classList.add("thick-border-top");
      if(c%3===0) cell.classList.add("thick-border-left");
      if(c===8)   cell.classList.add("thick-border-right");
      if(r===8)   cell.classList.add("thick-border-bot");
    }
  }
}

// === Backtracking Solver ===
let btCalls=0;
function validBT(g,r,c,v){
  for(let i=0;i<9;i++) if(g[r][i]===v||g[i][c]===v) return false;
  const br=Math.floor(r/3)*3, bc=Math.floor(c/3)*3;
  for(let i=0;i<3;i++) for(let j=0;j<3;j++) if(g[br+i][bc+j]===v) return false;
  return true;
}
function findEmpty(g){
  for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(g[r][c]===0) return {r,c};
  return null;
}
function solveBT(g){
  btCalls++;
  const e=findEmpty(g);
  if(!e) return true;
  const {r,c}=e;
  for(let n=1;n<=9;n++){
    if(validBT(g,r,c,n)){
      g[r][c]=n;
      if(solveBT(g)) return true;
      g[r][c]=0;
    }
  }
  return false;
}
function backtrackingSolve(orig){
  let total=0, callsFirst=0, res;
  for(let i=0;i<50;i++){
    const g=orig.map(r=>r.slice());
    btCalls=0;
    const t0=performance.now();
    solveBT(g);
    const t1=performance.now();
    if(i===0){ callsFirst=btCalls; res=g; }
    total += t1-t0;
  }
  return {grid:res, time:(total/50).toFixed(2), calls:callsFirst};
}

// === Dancing Links Solver ===
class DLXNode{constructor(){this.L=this;this.R=this;this.U=this;this.D=this;this.C=null}}
class ColumnNode extends DLXNode{constructor(n){super();this.name=n;this.size=0}}
function buildDLX(orig){
  const header=new ColumnNode("h"); header.L=header;header.R=header;
  const cols=[];
  for(let i=0;i<324;i++){
    const c=new ColumnNode(i);
    cols.push(c);
    c.R=header; c.L=header.L; header.L.R=c; header.L=c;
    c.U=c; c.D=c;
  }
  function addRow(r,c,n,idx){
    let first=null;
    idx.forEach(ci=>{
      const col=cols[ci];
      const node=new DLXNode();
      node.C=col;node.row=r;node.col=c;node.num=n;
      node.D=col;node.U=col.U;col.U.D=node;col.U=node;col.size++;
      if(!first){ first=node; first.L=first; first.R=first; }
      else{ node.R=first; node.L=first.L; first.L.R=node; first.L=node; }
    });
  }
  for(let r=0;r<9;r++) for(let c=0;c<9;c++){
    const v=orig[r][c];
    for(let n=1;n<=9;n++){
      if(v!==0 && n!==v) continue;
      const b=Math.floor(r/3)*3+Math.floor(c/3);
      addRow(r,c,n,[r*9+c,81+r*9+(n-1),162+c*9+(n-1),243+b*9+(n-1)]);
    }
  }
  return {header};
}
function cover(c){ c.R.L=c.L; c.L.R=c.R; for(let i=c.D;i!==c;i=i.D) for(let j=i.R;j!==i;j=j.R){ j.D.U=j.U; j.U.D=j.D; j.C.size--; } }
function uncover(c){ for(let i=c.U;i!==c;i=i.U) for(let j=i.L;j!==i;j=j.L){ j.C.size++; j.D.U=j; j.U.D=j; } c.R.L=c; c.L.R=c; }
let dlxSol=null;
function searchDLX(h,k,sol){
  if(h.R===h){ dlxSol=[...sol]; return true; }
  let c=h.R, min=c.size;
  for(let j=c.R;j!==h;j=j.R) if(j.size<min){ c=j; min=j.size; }
  cover(c);
  for(let r=c.D;r!==c;r=r.D){
    sol.push(r);
    for(let j=r.R;j!==r;j=j.R) cover(j.C);
    if(searchDLX(h,k+1,sol)) return true;
    sol.pop();
    for(let j=r.L;j!==r;j=j.L) uncover(j.C);
  }
  uncover(c);
  return false;
}
function dlxSolve(orig){
  let total=0, opsFirst=0, res;
  for(let i=0;i<50;i++){
    const g=orig.map(r=>r.slice());
    const {header}=buildDLX(g);
    dlxSol=null;
    const t0=performance.now();
    searchDLX(header,0,[]);
    const t1=performance.now();
    if(i===0){
      opsFirst=dlxSol?dlxSol.length:0;
      const board=Array.from({length:9},()=>Array(9).fill(0));
      if(dlxSol) dlxSol.forEach(n=>board[n.row][n.col]=n.num);
      res=board;
    }
    total += t1-t0;
  }
  return {grid:res, time:(total/50).toFixed(2), ops:opsFirst};
}

// === UI wiring ===
const puzzleSelect = document.getElementById("puzzleSelect"),
      loadBtn      = document.getElementById("loadPuzzleBtn"),
      solveBtn     = document.getElementById("solveBtn");

puzzles.forEach((p,i)=>{
  const opt=document.createElement("option");
  opt.value=i; opt.textContent=p.name;
  puzzleSelect.appendChild(opt);
});

let current=null;
loadBtn.onclick=()=>{
  current=parsePuzzle(puzzles[puzzleSelect.value].str);
  renderGrid(current,"inputGrid");
  document.getElementById("btGrid").innerHTML="";
  document.getElementById("dlxGrid").innerHTML="";
  document.getElementById("btInfo").textContent="";
  document.getElementById("dlxInfo").textContent="";
};
solveBtn.onclick();

// auto-load first
loadBtn.click();
</script>

</body>
</html>
