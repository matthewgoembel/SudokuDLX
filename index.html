<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Sudoku Solver Comparison</title>
  <style>
    /* === Presentation Theme === */
    body { 
      font-family: 'Segoe UI', sans-serif; 
      background-color: #2a1a3d;     /* dark purple */
      color: #ffffff;                /* white text */
      padding: 20px; 
    }
    h1, h2 {
      color: #ffffff;
    }
    .container { 
      display: flex; 
      gap: 40px; 
      justify-content: center;
      flex-wrap: wrap;
    }
    .panel { text-align: center; margin-bottom: 20px; }
    table { 
      border-collapse: collapse; 
      margin: 10px auto; 
      background-color: #3a274d;    /* slightly lighter purple */
    }
    td { 
      width: 30px; 
      height: 30px; 
      text-align: center; 
      border: 1px solid #ffffff;    /* white borders */
      font-size: 18px; 
      color: #ffffff;
    }
    .thick-border-top   { border-top:    3px solid #ffffff; }
    .thick-border-left  { border-left:   3px solid #ffffff; }
    .thick-border-right { border-right:  3px solid #ffffff; }
    .thick-border-bot   { border-bottom: 3px solid #ffffff; }
    select, button { 
      padding: 8px 16px; 
      margin: 5px;
      background-color: #8acdea;     /* aqua accent */
      color: #2a1a3d;                /* dark purple text */
      border: none; 
      border-radius: 4px;
      font-weight: bold;
      cursor: pointer;
    }
    select { width: 160px; }
    .info { margin-top: 8px; font-weight: bold; }
  </style>
</head>
<body>

  <h1>Sudoku Solver: Backtracking vs. Dancing Links</h1>
  <div>
    <label for="puzzleSelect">Choose a puzzle:</label>
    <select id="puzzleSelect"></select>
    <button id="loadPuzzleBtn">Load Puzzle</button>
    <button id="solveBtn">Solve Both</button>
  </div>

  <div class="container">
    <div class="panel">
      <h2>Input Puzzle</h2>
      <table id="inputGrid"></table>
    </div>
    <div class="panel">
      <h2>Backtracking Solution</h2>
      <table id="btGrid"></table>
      <div id="btInfo" class="info"></div>
    </div>
    <div class="panel">
      <h2>DLX Solution</h2>
      <table id="dlxGrid"></table>
      <div id="dlxInfo" class="info"></div>
    </div>
  </div>

<script>
// === Three Hard-coded Puzzles ===
const puzzles = [
  { name: "Easy",
    str: "530070000600195000098000060800060003400803001700020006060000280000419005000080079" },
  { name: "Medium",
    str: "003020600900305001001806400008102900700000008006708200002609500800203009005010300" },
  { name: "Hard",
    str: "000000907000420180000705026100904000050000040000507009920108000034059000507000000" }
];

// Utility: parse string to 9×9 array
function parsePuzzle(str) {
  const grid = [];
  for (let r = 0; r < 9; r++) {
    grid[r] = [];
    for (let c = 0; c < 9; c++) {
      const ch = str[r*9 + c];
      grid[r][c] = (ch === '0' || ch === '.') ? 0 : +ch;
    }
  }
  return grid;
}

// Utility: render a 9×9 array into a table
function renderGrid(grid, tableId) {
  const table = document.getElementById(tableId);
  table.innerHTML = "";
  for (let r = 0; r < 9; r++) {
    const row = table.insertRow();
    for (let c = 0; c < 9; c++) {
      const cell = row.insertCell();
      cell.textContent = grid[r][c] || "";
      if (r % 3 === 0) cell.classList.add("thick-border-top");
      if (c % 3 === 0) cell.classList.add("thick-border-left");
      if (c === 8)      cell.classList.add("thick-border-right");
      if (r === 8)      cell.classList.add("thick-border-bot");
    }
  }
}

// --- Backtracking Solver ---
let btCalls = 0;
function validBT(g, r, c, v) {
  for (let i=0; i<9; i++){
    if (g[r][i]===v||g[i][c]===v) return false;
  }
  const br = Math.floor(r/3)*3, bc = Math.floor(c/3)*3;
  for (let i=0;i<3;i++) for (let j=0;j<3;j++){
    if (g[br+i][bc+j]===v) return false;
  }
  return true;
}
function findEmpty(g) {
  for (let r=0;r<9;r++) for (let c=0;c<9;c++){
    if (g[r][c]===0) return {r,c};
  }
  return null;
}
function solveBT(g) {
  btCalls++;
  const e = findEmpty(g);
  if (!e) return true;
  const {r,c} = e;
  for (let n=1;n<=9;n++){
    if (validBT(g,r,c,n)){
      g[r][c]=n;
      if (solveBT(g)) return true;
      g[r][c]=0;
    }
  }
  return false;
}
function backtrackingSolve(orig) {
  const grid = orig.map(r=>r.slice());
  btCalls = 0;
  const t0 = performance.now();
  solveBT(grid);
  const t1 = performance.now();
  return {grid, time: (t1-t0).toFixed(2), calls: btCalls};
}

// --- Dancing Links Solver ---
class DLXNode { constructor(){ this.L=this;this.R=this;this.U=this;this.D=this;this.C=null;}}
class ColumnNode extends DLXNode {
  constructor(name){ super(); this.name=name; this.size=0; }
}
function buildDLX(orig) {
  const header = new ColumnNode("h");
  header.L = header; header.R = header;
  const cols = [];
  for (let i=0;i<324;i++){
    const c = new ColumnNode(i);
    cols.push(c);
    c.R = header; c.L=header.L; header.L.R=c; header.L=c;
    c.U=c; c.D=c;
  }
  function addRow(r,c,n,indices) {
    let first=null;
    indices.forEach(ci=>{
      const col = cols[ci];
      const node=new DLXNode();
      node.C=col;
      node.row=r; node.col=c; node.num=n;
      // vertical
      node.D=col; node.U=col.U; col.U.D=node; col.U=node; col.size++;
      // horizontal
      if(!first){ first=node; first.L=first; first.R=first; }
      else { node.R=first; node.L=first.L; first.L.R=node; first.L=node; }
    });
  }
  for (let r=0;r<9;r++){
    for (let c=0;c<9;c++){
      const v = orig[r][c];
      for (let n=1;n<=9;n++){
        if (v!==0 && n!==v) continue;
        const b = Math.floor(r/3)*3+Math.floor(c/3);
        addRow(r,c,n,[
          r*9+c,
          81 + r*9+(n-1),
          162 + c*9+(n-1),
          243 + b*9+(n-1)
        ]);
      }
    }
  }
  return {header};
}
function cover(c) {
  c.R.L=c.L; c.L.R=c.R;
  for (let i=c.D;i!==c;i=i.D) {
    for (let j=i.R;j!==i;j=j.R){
      j.D.U=j.U; j.U.D=j.D; j.C.size--;
    }
  }
}
function uncover(c) {
  for (let i=c.U;i!==c;i=i.U){
    for (let j=i.L;j!==i;j=j.L){
      j.C.size++; j.D.U=j; j.U.D=j;
    }
  }
  c.R.L=c; c.L.R=c;
}
let dlxSol=null;
function searchDLX(h, k, sol) {
  if (h.R===h){ dlxSol=[...sol]; return true; }
  let c=h.R, min=c.size;
  for (let j=c.R;j!==h;j=j.R) if(j.size<min){c=j;min=j.size;}
  cover(c);
  for (let r=c.D;r!==c;r=r.D){
    sol.push(r);
    for (let j=r.R;j!==r;j=j.R){ cover(j.C); }
    if (searchDLX(h,k+1,sol)) return true;
    sol.pop();
    for (let j=r.L;j!==r;j=j.L){ uncover(j.C); }
  }
  uncover(c);
  return false;
}
function dlxSolve(orig) {
  const grid = orig.map(r=>r.slice());
  const {header} = buildDLX(grid);
  dlxSol=null;
  const t0=performance.now();
  searchDLX(header,0,[]);
  const t1=performance.now();
  const res=Array.from({length:9},()=>Array(9).fill(0));
  if (dlxSol){
    dlxSol.forEach(node=>{
      res[node.row][node.col]=node.num;
    });
  }
  return {grid:res, time:(t1-t0).toFixed(2), ops:dlxSol?dlxSol.length:0};
}

// === UI wiring ===
const puzzleSelect = document.getElementById("puzzleSelect");
const loadBtn       = document.getElementById("loadPuzzleBtn");
const solveBtn      = document.getElementById("solveBtn");

// Populate dropdown
puzzles.forEach((p,i)=>{
  const opt=document.createElement("option");
  opt.value=i; opt.textContent=p.name;
  puzzleSelect.appendChild(opt);
});

let current=null;
loadBtn.onclick = ()=>{
  current = parsePuzzle(puzzles[puzzleSelect.value].str);
  renderGrid(current,"inputGrid");
  document.getElementById("btGrid").innerHTML = "";
  document.getElementById("dlxGrid").innerHTML = "";
  document.getElementById("btInfo").textContent="";
  document.getElementById("dlxInfo").textContent="";
};
solveBtn.onclick = ()=>{
  if (!current) return alert("Load a puzzle first!");
  const bt = backtrackingSolve(current);
  renderGrid(bt.grid,"btGrid");
  document.getElementById("btInfo").textContent = `Time: ${bt.time} ms | Calls: ${bt.calls}`;
  const dx = dlxSolve(current);
  renderGrid(dx.grid,"dlxGrid");
  document.getElementById("dlxInfo").textContent = `Time: ${dx.time} ms | Ops: ${dx.ops}`;
};

// auto-load first
loadBtn.click();
</script>

</body>
</html>
